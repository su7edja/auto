(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{44:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var o=[{id:"pages/auto-version.md",body:"# `auto version`\n\nGet the semantic version bump for the given changes. Requires all PRs to have labels for the change type. If a PR does not have a label associated with it, it will default to `patch`.\n\n```bash\n>  auto version -h\n\nOptions\n\n  --only-publish-with-release-label    Only bump version if 'release' label is on pull request\n  --skip-release-labels string[]       Labels that will not create a release. Defaults to just 'skip-release'\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  Get the new version using the last release     $ auto version\n  to head\n  Skip releases with multiple labels             $ auto version --skip-release-labels documentation CI\n\n```\n\nUseful in conjunction with `npm version` to auto-version releases.\n\n## Prerelease\n\nTo create a prerelease add the `prerelease` label to your pull request.\n\n## No Release\n\nTo not create a release for a pull request add the `skip-release` label. Any pull request with this tag will make `auto version` return `''`.\n\n::: message is-warning\n:warning: You must check the return value of `auto version` in a bash script like in the example configuration for the `skip-release` label to function properly.\n:::\n\n### Multiple\n\nYou can configure multiple labels to skip releasing as well. To do this use the `skipReleaseLabels` options. This can also be configured via the [.autorc](/auto/pages/autorc.html#multiple-no-version).\n\n```sh\nauto version --skip-release-labels project-files --skip-release-labels documentation\n```\n\n## Configure Versioning Labels\n\nYou can customize the versioning labels in the `.autorc`. To see configuration [go here](/auto/pages/autorc.html#versioning-labels).\n"},{id:"home.md",body:"::: hero is-primary is-purple is-bold is-medium has-text-centered\n\n# auto release\n\n## CLI tools to help facilitate semantic versioning based on GitHub PR labels\n\n:::\n\n## Adding automated releases shouldn't be hard or require changing your workflow /.no-link .has-text-purple .has-text-centered\\\n\n`auto` makes automating releases for your open source project as simple as labels to pull requests. Releasing often means being confident in your releases. /.has-text-centered\\\n\n||| row has-text-centered wide\n\n::: box\n\n### Release Labels\n\nManaging releases has never been easier. Just add a label!\n:::\n\n::: box\n\n### Beautiful Changelogs\n\nLink to PRs and Jira stories, include authors, monorepo aware, customizable\n:::\n\n::: box\n\n### PR Interaction\n\nSet statuses, check labels and comment on pull requests\n:::\n\n|||\n\n||| row has-text-centered wide\n\n::: box\n\n### Atomic Functions\n\n`auto` functions do 1 thing and they do it well. Easily use them to fit any build process\n:::\n\n::: box\n\n### No Strict Commits\n\nOther tools require you to change how any contributor commits to you project. With `auto` leave that baggage behind!\n:::\n\n::: box\n\n### Fast Workflow\n\nSince all you need to worry about are labels you can work at an incredibly fast pace! This speed to commit also helps with new contributors\n:::\n\n|||\n\n::: hero is-info is-yellow is-small has-text-centered\nRelease Tools\n:::\n\n::::: hero is-small\n:::: div columns\n::: div column feature\n\n# `auto version`\n\nGet the semantic version bump using merged PRs\n\n:::\n::: div column\n![Markdown](images/version.png)\n:::\n::::\n:::::\n\n:::::: hero is-light is-small\n::::: div columns\n::: div column is-three-fifths\n![Markdown](images/changelog.png)\n:::\n:::: div column feature\n\n# `auto changelog`\n\nPrepend release notes to `CHANGELOG.md`.\n\n::: div content list\n\n- link PRs and Jira stories\n- attach effected packages in monorepo\n- list authors\n- customizable sections\n\n:::\n\n::::\n:::::\n::::::\n\n::::: hero is-small\n:::: div columns\n::: div column feature\n\n# `auto release`\n\nAuto-generate a github release.\n\n:::\n::: div column is-three-fifths\n![Markdown](images/release.png)\n:::\n::::\n:::::\n\n::::: hero is-light is-small no-margin\n:::: div columns\n::: div column\n![Markdown](images/shipit.png)\n:::\n::: div column feature\n\n# `auto shipit`\n\nDo all of the above in one simple command!\n:::\n::::\n:::::\n\n::: hero is-red is-link is-small has-text-centered\nPull Request Tools\n:::\n\n:::::: hero is-small\n::::: div columns\n::: div column\n![Markdown](images/pr.png)\n:::\n:::: div column feature\n\n# `auto pr`\n\nSet the status on a PR commit\n\n::::\n:::::\n::::::\n\n::::: hero is-small is-light no-margin\n:::: div columns\n::: div column feature\n\n# `auto comment`\n\nComment on a pull request with a markdown message.\n\n:::\n::: div column\n![Markdown](images/comment.png)\n:::\n::::\n:::::\n\n:::: hero is-link is-purple is-small has-text-centered\n\n# Win back your time and be confident in releasing! /.no-link .title .is-4 .has-text-centered\\\n\n::: button is-large is-link is-bold is-inverted is-outlined\n[Get Started :tada:](/auto/pages/GettingStarted.html)\n:::\n\n::::\n"},{id:"pages/autorc.md",body:'# `auto` RC File\n\nAll options for the CLI tools can also be configured via the `.autorc`. As CLI options you supply them in snake-case (`--foo-bar`), but as `.autorc` options you supply them in camelCase (`fooBar`),\n\nWe use [cosmiconfig](https://github.com/davidtheclark/cosmiconfig) to find your config, so that means you can define this file a variety of ways. By default, Cosmiconfig will start at the root of your project and start to search up the directory tree for the following:\n\n- a package.json property\n- a JSON or YAML, extension-less "rc file"\n- an "rc file" with the extensions .json, .yaml, .yml, or .js.\n- a .config.js CommonJS module\n\n## Initialization\n\nTo interactively create an `.autorc` use the `init` command. You can configure most flags and all labels/changelogTitles.\n\n```sh\nauto init\n```\n\n## Exclusive\n\nThese options can be set exclusively in the `.autorc` and do not exist as CLI flags.\n\n### Extending\n\nIf you want to share your auto configuration between projects you can use the `extends` property. This property will load an autorc object or a function that returns an autorc object and merge it with your project\'s `.autorc`.\n\nAuto can load `extends` configs in the following ways:\n\n- from a path `path/to/config`\n- from a scoped package `@YOUR_SCOPE/auto-config`\n- from a package `auto-config-YOUR_NAME`\n\n### Labels\n\nTo override any of the default labels use the `labels` seciton in the `.autorc`.\n\n```json\n{\n  "labels": {\n    "major": "Version: Major",\n    "minor": "Version: Minor",\n    "patch": "Version: Patch",\n    "skip-release": "NO!",\n    "release": "Autobots, rollout!",\n    "prerelease": "beta"\n  }\n}\n```\n\n#### Label Customization\n\nYou can customize everything about a label\n\n- `name` - The label text used for the label. If omitted defaults to the `key` value\n- `title` - The title to use in the changelog\n- `description` - The description to use when creating the label\n- `color` - The color of the label. Can be specified as a string in any of [these](https://github.com/bgrins/TinyColor#accepted-string-input) ways. If not specified the color is random\n\n```json\n{\n  "labels": {\n    "major": {\n      "name": "Version: Major",\n      "title": "The API has changed:",\n      "description": "Add this label to a PR to create a major release",\n      "color": "blue"\n    },\n    ...\n  }\n}\n```\n\n#### Changelog Titles\n\nBy default auto will create sections in the changelog for the following labels.\n\n- major\n- minor\n- patch\n- internal\n- documentation\n\nTo customize the title for the section in the changelog you can\n\n```json\n{\n  "labels": {\n    "documentation": {\n      "title": "Docz"\n    },\n    ...\n  }\n}\n```\n\nIf you want more sections in your changelog to further detail the change-set you can\nuse the `labels` section to add more. Any label in the label section with a title\nwill become a special section in your changelog.\n\nThe following adds a `typescript` label to the project that we can use to denote changes\nrelated to a TypeScript re-write.\n\n```json\n{\n  "labels": {\n    "typescript": {\n      "title": "TypeScript Rewrite"\n    },\n    ...\n  }\n}\n```\n\n#### Multiple `skip-release`\n\nYou can configure multiple labels to skip releases.\n\n```json\n{\n  "skipReleaseLabels": ["documentation", "project-files"]\n}\n```\n\n#### Arbitrary Labels\n\nIf you want to `auto create-labels` to add other labels to your project (ones that aren\'t used for\nversioning or the changelog), you can use the `labels` section. Just omit the `title` property.\n\n```json\n{\n  "labels": {\n    "good first issue": {\n      "description": "This is an issue that first time contributors can tackle easily",\n      "color": "purple"\n    },\n    ...\n  }\n}\n```\n\n### Slack URL\n\nYou can set where `auto` posts for slack messages.\n\n```json\n{\n  "slack": "https://url-to-slack.com"\n}\n```\n\n## CLI args\n\nYou can set any CLI option in the `.autorc` these options will get overridden by the CLI flags.\n\nThe following are options that might be more useful to set in the `.autorc` rather than with a flag.\n\n### Plugins\n\nIt is useful to specify your plugins in the rc file rather than in all the commands.\n\n```json\n{\n  "plugins": ["npm", "../path/to/plugin.js", "NPM_PACKAGE_NAME"]\n}\n```\n\n### Jira\n\nTo include Jira story information in your changelogs you must include a URL to your hosted JIRA instance.\n\n```json\n{\n  "jira": "https://url-to-jira.com"\n}\n```\n\n### githubApi\n\nIf you are using enterprise github, `auto` lets you configure the github API URL that it uses.\n\n```json\n{\n  "jira": "https://url-to-jira.com"\n}\n```\n\n### name\n\nGit name to commit and release with. Defaults to package.json. Used in `auto changelog` and `auto release`\n\n```json\n{\n  "name": "Joe Schmo"\n}\n```\n\n### email\n\nGit email to commit and release with. Defaults to package.json. Used in `auto changelog` and `auto release`\n\n```json\n{\n  "email": "joe@schmo.com"\n}\n```\n'},{id:"pages/auto-changelog.md",body:"# `auto changelog`\n\nPrepend release notes to `CHANGELOG.md`, create one if it doesn't exist, and commit the changes.\n\n::: message is-warning\n:warning: This should be run before `npm version` so the `CHANGELOG.md` changes are committed before the release gets tagged.\n:::\n\n```bash\n>  auto changelog -h\n\nOptions\n\n  -d, --dry-run          Report what command will do but do not actually do anything\n  --no-version-prefix    Use the version as the tag without the 'v' prefix\n  --jira string          Jira base URL\n  --from string          Tag to start changelog generation on. Defaults to latest tag.\n  --to string            Tag to end changelog generation on. Defaults to HEAD.\n  -m, --message string   Message to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]'\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  Generate a changelog from the last release     $ auto changelog\n  to head\n  Generate a changelog across specific           $ auto changelog --from v0.20.1 --to v0.21.0\n  versions\n```\n\n## Jira\n\nTo include Jira story information you must include a URL to your hosted JIRA instance as a CLI flag or [.autorc`](/auto/pages/autorc.html) config option.\n\n## Changelog Titles\n\nYou can customize the changelog titles and even add custom ones. To see configuration [go here](/auto/pages/autorc.html#changelog-titles).\n"},{id:"index.md",body:":tada: Welcome\n\n- [Introduction](/auto/pages/introduction.html)\n- [Getting Started](/auto/pages/getting-started.html)\n\n---\n\n:hammer: Tool APIs :wrench:\n\n- [Setup](/auto/pages/auto-init.html)\n  - [auto init](/auto/pages/auto-init.html#auto-init)\n  - [auto create-labels](/auto/pages/auto-init.html#auto-create-labels)\n- [Publishing](/auto/pages/publishing.html)\n  - [auto version](/auto/pages/auto-version.html)\n  - [auto changelog](/auto/pages/auto-changelog.html)\n  - [auto release](/auto/pages/auto-release.html)\n  - [auto shipit](/auto/pages/auto-shipit.html)\n- [PR Interaction](/auto/pages/pr-interaction.html)\n  - [auto label](/auto/pages/auto-label.html)\n  - [auto pr](/auto/pages/auto-pr.html)\n  - [auto pr-check](/auto/pages/auto-pr-check.html)\n  - [auto comment](/auto/pages/auto-comment.html)\n\n---\n\n:gear: Configuration\n\n- [.autorc](/auto/pages/autorc.html)\n- [Plugins](/auto/pages/plugins.html)\n  - [Writing Plugins](/auto/pages/writing-plugins.html)\n  - [Chrome Web Store](/auto/pages/chrome.html)\n- [Troubleshooting](/auto/pages/troubleshooting.html)\n\n---\n\n:bathtub: Continuos Integration\n\n- [CircleCI](/auto/pages/circleci.html)\n"},{id:"pages/circleci.md",body:"# CircleCI\n\nThe following config declares the `release` job and uses it in the `build_and_release` workflow. The `release` job will only run on commits to master.\n\n```yaml\nversion: 2\n\ndefaults: &defaults\n  working_directory: ~/auto\n  docker:\n    - image: circleci/node:latest-browsers\n\njobs:\n  install: # your install job\n\n  release:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/auto\n      - run:\n          name: Release\n          command: npm run release\n\nworkflows:\n  version: 2\n  build_and_release:\n    jobs:\n      - install:\n          filters:\n            tags:\n              only: /.*/\n\n      - release:\n          requires:\n            - install\n          filters:\n            branches:\n              only:\n                - master\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- `NPM_TOKEN` is set (with the NPM plugin)\n\n### Problems pushing tags to github?\n\nGo to Settings -> Checkout SSH Keys -> `Create and add YOUR_USERNAME user key`. This will create a key with the ability to push to github.\n"},{id:"pages/auto-label.md",body:"# `auto label`\n\nGet the labels for a pull request. Doesn't do much, but the return value lets you write you own scripts based off of the PR labels!\n\n```bash\n>  auto label -h\n\nOptions\n\n  --pr number   The pull request number you want the labels of (defaults to last merged PR)\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto label --pr 123\n```\n\n## Without PR Number\n\nRunning `auto label` without the PR number enables it to run in master after a PR has been merged. You can use these labels to automate more things in your merge build pipeline other than the release.\n\n`auto` the project uses this to only deploy the documentation when the last merged PR has a `documentation` label.\n"},{id:"pages/auto-comment.md",body:'# `auto comment`\n\nComment on a pull request with a markdown message.\n\n```sh\nauto comment --pr 24 --message "You broke the build!" --context build\n```\n\n## Options\n\n```bash\n>  auto version -h\n\nOptions\n\n  --pr number [required]            The pull request number you want the labels of\n  --context string                  A string label to differentiate this status from others\n  -m, --message string [required]   Message to post to comment\n  -d, --dry-run                     Report what command will do but do not actually do anything\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto comment --pr 123 --comment "# Why you\'re wrong..."\n```\n'},{id:"pages/auto-init.md",body:"# Initialization\n\n`auto` provides some tools to quickly set up your project. If you do not want to use the interactive experience all these options can be configured via the [.autorc](/auto/pages/autorc.html) and most can be configure via CLI options.\n\n## `auto init`\n\nInteractive setup for most configurable options.\n\n```sh\n$ auto init --help\n\nOptions\n\n  --only-labels    Only run init for the labels. As most other options are for advanced users\n  -d, --dry-run    Report what command will do but do not actually do anything\n\nExamples\n\n  $ auto init\n```\n\n## `auto create-labels`\n\nCreate your project's labels on github.\n\n```sh\n$ auto create-labels --help\n\nOptions\n\n  -d, --dry-run    Report what command will do but do not actually do anything\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package.json\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package.json\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto create-labels\n```\n\n::: message is-warning\n:warning: For this to work you must have a `GH_TOKEN` set, ex: `GH_TOKEN=YOUR_TOKEN auto create-labels`\n:::\n"},{id:"pages/introduction.md",body:"![Markdown](../images/auto.gif)/.header-image\\\n\n# :rocket: auto :rocket:/.has-text-centered\\\n\nCI/CD helpers for github releases. Generate releases based on semantic version labels on pull requests.\n\nRelease Features:\n\n- Release every merge to master based on a PR labels\n- Skip a release with the `skip-release` label\n- Generate a changelog with fancy headers, authors, and monorepo package association\n- Generate a GitHub release\n\nPull Request Interaction Features:\n\n- Get the labels for a PR\n- Set the status of a PR\n- Check that a pull request has a SemVer label\n- Comment on a PR with markdown\n"},{id:"pages/auto-shipit.md",body:"# `auto shipit`\n\nRun the full `auto` release pipeline. Will detect if in a lerna project and publish accordingly.\n\n```sh\nauto shipit\n```\n\n## Options\n\n```sh\n\n$ auto shipit --help\n\nOptions\n\n  -d, --dry-run    Report what command will do but do not actually do anything\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto shipit\n```\n"},{id:"pages/auto-pr.md",body:"# `auto pr`\n\nSet the status on a PR commit\n\n## Options\n\n```bash\n>  auto pr -h\n\nOptions\n\n  --sha string                      Specify a custom git sha. Defaults to the HEAD for a git repo in the current repository\n  --pr number [required]            The pull request number you want the labels of\n  --url string                      URL to associate with this status\n  --state string [required]         State of the PR. ['pending', 'success', 'error', 'failure']\n  --description string [required]   A description of the status\n  --context string [required]       A string label to differentiate this status from others\n  -d, --dry-run                     Report what command will do but do not actually do anything\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n$ auto pr \\\n   --pr 32 \\\n   --state pending \\\n   --description \"Build still running...\" \\\n   --context build-check\n```\n"},{id:"pages/auto-release.md",body:'# `auto release`\n\nAuto-generate a github release.\n\n```json\n{\n  "scripts": {\n    "postpublish": "auto release"\n  }\n}\n```\n\nMake sure the branch/tag you\'re releasing is on github before running `auto release`.\nYou will need to push the tags to github first:\n\n```json\n{\n  "scripts": {\n    "postpublish": "git push --follow-tags --set-upstream origin $branch && auto release"\n  }\n}\n```\n\n## Options\n\n```bash\n>  auto release -h\n\nOptions\n\n  -d, --dry-run          Report what command will do but do not actually do anything\n  --no-version-prefix    Use the version as the tag without the \'v\' prefix\n  --jira string          Jira base URL\n  --use-version string   Version number to publish as. Defaults to reading from the package definition for the platform.\n  -s, --slack string     Url to post a slack message to about the release. If slack url\n                         supplied via autorc this flag can act as a boolean.  Make sure the\n                         SLACK_TOKEN environment variable is set.\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto release\n```\n\n## Slack URL\n\nWhen posting to slack you must provide your slack services hook url at the CLI or in your `.autorc` config. To see configuration [go here](/auto/pages/autorc.html#slack-url).\n'},{id:"pages/auto-pr-check.md",body:"# `auto pr-check`\n\nCheck that a pull request has a SemVer label.\n\n```sh\nauto pr-check --pr 24 --url http://your-ci.com\n```\n\n## Options\n\n```bash\n>  auto pr-check -h\n\nOptions\n\n  --pr number [required]               The pull request number you want the labels of\n  --url string                         URL to associate with this status\n  --only-publish-with-release-label    Only bump version if 'release' label is on pull request\n  --context string                     A string label to differentiate this status from others\n  --skip-release-labels string[]       Labels that will not create a release. Defaults to just 'skip-release'\n  -d, --dry-run                        Report what command will do but do not actually do anything\n\nGlobal Options\n\n  -h, --help            Display the help output for the command\n  -v, --verbose         Show some more logs\n  -w, --very-verbose    Show a lot more logs\n  --repo string         The repo to set the status on. Defaults to looking in the package definition for the platform\n  --owner string        The owner of the GitHub repo. Defaults to reading from the package definition for the platform\n  --github-api string   GitHub API to use\n  --plugins string[]    Plugins to load auto with. (defaults to just npm)\n\nExamples\n\n  $ auto pr-check --pr 32 --url http://your-ci.com/build/123\n```\n"},{id:"pages/chrome.md",body:'# Chrome Web Store\n\nThis plugin allows you to automate the publishing of chrome extensions\n\n::: message is-success\nExample Repo: [here](https://github.com/hipstersmoothie/auto-chrome)\n:::\n\n## Package Configuration\n\nYou must first pack/zip your plugin before running `auto`.\n\nThese environment variables tell `auto` what to publish.\n\n- EXTENSION_ID - your chrome extensions unique ID (REQUIRED)\n- EXTENSION_BUILD - Path to either a zip file, or a directory to be zip. defaults to `extension.zip`\n\nOr you can set these values in the autorc:\n\n```json\n{\n  "plugins": [\n    [\n      "chrome",\n      {\n        "id": "1234",\n        "build": "path/to/zip/or/folder",\n        "manifest": "path/tp/manifest.json"\n      }\n    ]\n  ]\n}\n```\n\n::: message is-warning\n:warning: You must have a manifest.json for this plugin to work.\n:::\n\n## Chrome Environment Variables\n\nTo publish to the chrome web store you will need the following values. See [here](https://github.com/DrewML/chrome-webstore-upload/blob/master/How%20to%20generate%20Google%20API%20keys.md) for a guide one how to get these values.\n\n- CLIENT_ID\n- CLIENT_SECRET\n- REFRESH_TOKEN\n'},{id:"pages/getting-started.md",body:'# Getting Started\n\nBefore we do anything we must first install `auto` as a dev dependency.\n\n```sh\nyarn add -D auto\n```\n\n## Enterprise\n\nIf you are using enterprise github `auto` lets you configure the github API URL that it uses. You can configure this by using the CLI option `--github-api`, by setting the value in your [.autorc](/auto/pages/autorc.html#githubApi), or during `auto init`.\n\n### Project already published\n\nIf you\'re project is already published then you need to make sure that your last release is tagged and that it\'s the `Latest Release` on GitHub.\n\nTo tag your last release find that last commit where you bumped the version and run the following commands with your version number.\n\n```sh\ngit tag v1.2.3\ngit push --tags\n```\n\nThen on GitHub go to your project\'s releases and click `Draft a new release`. In the `Tag version` field enter the version number you just tagged and click `Publish release`.\n\nNow your github project is set up to use `auto`.\n\n## Configuration\n\nGetting started with `auto` is super easy.\n\n1. `auto init` (optional)\n2. `auto create-labels`\n3. Configure environment variables\n4. Set up script\n\n### 1. Initialize Options\n\nInitialize all options and configure label text. If this is not run then `auto` will use the default configuration. This command will produce and `.autorc`, this contains advanced configuration and might not be needed.\n\n### 2. Labels\n\nAfter that, you need to set up the labels on your github project. The types of labels that `auto` uses are:\n\n- Versioning Labels - used to calculate version numbers and make releases. To change them refer to [this](/auto/pages/autorc.html#versioning-labels).\n- Changelog Labels - These labels do not effect the version calculation but they will change the section the PR displays in the changelog. These are customizable too, and you can even add your own sections. Read more [here](/auto/pages/autorc.html#changelog-titles)\n\nTo create the labels for your project on GitHub, run the following command with your `GH_TOKEN`.\n\n```sh\nGH_TOKEN=YOUR_TOKEN auto create-labels\n```\n\n### 3. Environment Variables\n\nYou must configure some environment variables for publishing and releasing to work properly.\n\n- `GH_TOKEN` - Used for updating the changelog and publishing the GitHub release\n- `NPM_TOKEN` - Used to publish to npm. (only with NPM plugin)\n\nYou can also store these values in a local file at the root of your project named `.env`. You should make sure to add this file to your `.gitignore` so you don\'t commit any keys!\n\n```bash\nGH_TOKEN=YOUR_TOKEN\nNPM_TOKEN=PUBLISH_TOKEN\n```\n\n### 4. Script\n\n`auto` is written so that each tool it exposes is useful in isolation. It also provides workflows for those who don\'t care about the details of each tool and just want their code released.\n\n#### Quick Setup\n\nTo version, changelog, publish and release your code all at the same time, we\'ve included the `shipit` tool. This tool takes the default `auto` workflow and puts it into one command.\n\n```json\n{\n  "scripts": {\n    "release": "auto shipit"\n  }\n}\n```\n\n#### Detailed Setup\n\nThe simplest workflow to get set up in just the `package.json` is by adding the following to your `package.json`. With this setup your application will not be able to use the `skip-release` flag, but everything else will work just fine\n\n```json\n{\n  "scripts": {\n    "version": "npm version `auto version` -m \'Bump version to: %s [skip ci]\'",\n    "publish": "npm publish && git push --follow-tags --set-upstream origin $branch",\n    "release": "auto changelog && npm run version && npm run publish && auto release"\n  }\n}\n```\n\n##### Enabling `skip-release` label\n\nTo use the `skip-release` label you have to get a little more involved and use a shell script. We could do the `if` checks in the `package.json`, but this would get messy and hard to read very quickly.\n\n```json\n{\n  "scripts": {\n    "release": "./scripts/release.sh"\n  }\n}\n```\n\nHere is an example release script for a single NPM package:\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\n## Support for label \'skip-release\'\nif [ ! -z "$VERSION" ]; then\n  ## Update Changelog\n  auto changelog\n\n  ## Publish Package\n  npm version $VERSION -m "Bump version to: %s [skip ci]"\n  npm publish\n\n  ## Create GitHub Release\n  git push --follow-tags --set-upstream origin $branch\n  auto release\nfi\n```\n\nor if you are using lerna to manage a monorepo.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\nif [ ! -z "$VERSION" ]; then\n  auto changelog\n  lerna publish --yes --force-publish=* $VERSION -m \'%v [skip ci]\'\n  auto release\nfi\n```\n'},{id:"pages/plugins.md",body:'# Plugins\n\n`auto` uses the package [tapable](https://github.com/webpack/tapable) to expose a plugin system.\n\nCurrent official plugins:\n\n- npm - publish code to npm (DEFAULT)\n- chrome - publish code to Chrome Web Store\n- conventional-commits - parse conventional commit messages for version bumps\n\n## Using Plugins\n\nTo use a plugin you can either supply the plugin via a CLI arg or in your [.autorc](/auto/pages/autorc.html#plugins).\n\nThere are three ways to load a plugin.\n\n### 1. Official Plugins\n\nTo use an official plugin all you have to do is supply the name. Currently the only supported plugin is the `npm` plugin.\n\n```sh\nauto shipit --plugins npm\n```\n\n### 2. `npm` package\n\nIf you are using a plugin distributed on `npm` simply supply the name.\n\n```sh\nauto shipit --plugins NPM_PACKAGE_NAME\n```\n\n### 3. Path\n\nOr if you have a plugin locally supply the path.\n\n```sh\nauto shipit --plugins ../path/to/plugin.js\n```\n\n### Multiple\n\nIf you want to use multiple plugins you can supply multiple.\n\n```sh\nauto shipit --plugins npm NPM_PACKAGE_NAME ../path/to/plugin.js\n```\n\n### Plugin Configuration\n\nTo provide plugin specific config change the following:\n\n```json\n{\n  "plugins": ["chrome"]\n}\n```\n\nTo this:\n\n```json\n{\n  "plugins": [\n    ["chrome", { "extensionId": "1234", "build": "my-compiled-extension.zip" }]\n  ]\n}\n```\n'},{id:"pages/pr-interaction.md",body:"# Pull Request Interaction\n\n`auto` also includes a variety of PR interaction tools to update PRs from the CI. You can use these tools in various ways to make your PR validation process much more customized.\n\n<br />\n\nTools:\n\n:star: [auto-label](/auto/pages/auto-label.html) - Get the labels for a PR\n\n:star: [auto-pr](/auto/pages/auto-pr.html) - Set a status on a PR\n\n:star: [auto-pr-check](/auto/pages/auto-pr-check.html) - Check for a semver label and set a status\n\n:star: [auto-comment](/auto/pages/auto-comment.html) - Comment on a PR\n"},{id:"pages/publishing.md",body:"# Publishing\n\n`auto`'s main use it to automate the release process for your project This can be broken down into three core steps:\n\n```text\npre: (optional) Check if new version\n\n1. Generate CHANGELOG.md\n2. Publish code\n3. Generate github release notes\n```\n\n`auto` makes no assumptions about your publishing process. Each tool is a function that can be run in isolation and only does one thing really well. For instance, you could just use `auto changelog` to generate the changelog and nothing else or use `auto version` to calculate just the semver bump.\n"},{id:"pages/troubleshooting.md",body:'# Troubleshooting\n\n## Error: Can\'t find a GitHub token to use\n\nYou must set a `GH_TOKEN` for `auto` to work. Make sure to add your `NPM_TOKEN` while you\'re at it.\n\n## npm ERR! Git working directory not clean\n\nTo version and publish you cannot have any changes in the git repo during publish. This means that if you build some files before release that aren\'t git-ignored `auto` will fail to continue. To fix this either add those `dist` files to your `.gitignore` or commit them somehow before the release.\n\n## npm ERR! need auth auth required for publishing\n\nThis error will occur when you do not have a `NPM_TOKEN` set.\n\n### Still getting errors?!\n\nMake sure that npm is trying to publish to the correct registry. Force npm/lerna to use the public registry by adding the following to your package.json:\n\n```json\n{\n  "publishConfig": {\n    "registry": "https://registry.npmjs.org/"\n  }\n}\n```\n\n## Hangs on: Are you sure you want to continue connecting (yes/no)?\n\nThis mean your environment does not trust github. To change this add this command somewhere before `auto`\n\npublic:\n\n```sh\nmkdir ~/.ssh/ && echo -e "Host github.com\\n\\tStrictHostKeyChecking no\\n" > ~/.ssh/config\n```\n\nenterprise:\n\n```sh\nmkdir ~/.ssh/ && echo -e "Host github.YOUR_COMPANY.com\\n\\tStrictHostKeyChecking no\\n" > ~/.ssh/config\n```\n\n## You cannot publish over the previously published versions\n\nIf you\'ve encountered any of these errors you\'ll probably run into this problem. If the whole release process doesn\'t complete you can end up in a state when `auto` published the new version, but doesn\'t push that back to github. To fix this just bump the version number to the "previously published version".\n\n## Cannot read owner and package name from GitHub URL in package.json\n\nThis means that you do not have a repository set in your package.json. Add something along the line of:\n\n```json\n{\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/intuit/auto"\n  },\n  // or simply\n  "repository": "intuit/auto"\n}\n```\n\n## How do I auto a fork of another repo?\n\nIf auto doesn\'t find a last release it will default to the first commit for version calculation (and a log of other things). If you have forked a repo, you fork all the merge commit messages as well. This confuses `auto` since it will look for those pull requests in your fork and not the main one.\n\nTo remedy this first tag your first commit in the fork with your first version. If the tags from the original repo are still in your repo you should just bump that version. This will let `auto` ignore all the old merge commits.\n\n::: message is-warning\n:warning: You must also match this new tag version in your package.json\n:::\n\n```sh\n# Set head to last release and tag it with 2.10.1\ngit tag v2.10.1\n```\n\nThen on GitHub go to your project, click release, then draft a new release. Select the tag you just published and `publish release`. Now auto will be able to use the correct version and git log!\n'},{id:"pages/writing-plugins.md",body:"# Writing Plugins\n\nIf you've ever written a webpack plugin it's a lot like that.\n\nA plugin definition is:\n\n- a class the has an `apply` function where a plugin hooks into various functions in auto (REQUIRED)\n- a constructor where you can load plugin specific config\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\nexport default class TestPlugin implements IPlugin {\n  private readonly config: any;\n\n  constructor(config: any) {\n    this.config = config;\n  }\n\n  apply(auto: Auto) {\n    // hook into auto\n  }\n}\n```\n\n## Constructor\n\nIn the constructor you have access to any plugin specific config provided in the `.autorc`. It might be useful to write a more type-safe interface for your config.\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\ninterface ITestPluginConfig {\n  foo?: string;\n  bar?: boolean;\n}\n\nexport default class TestPlugin implements IPlugin {\n  private readonly config: ITestPluginConfig;\n\n  constructor(config: ITestPluginConfig) {\n    this.config = config;\n  }\n}\n```\n\n## Hooks\n\nPlugins work by hooking into various actions that `auto` has to do in order to facilitate a release or interact with your GitHub repo. The hooks that it exposes are:\n\n---\n\n### Main Hooks\n\n#### beforeRun\n\nHappens before anything is done. This is a great place to check for platform specific secrets such as a NPM token.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async config => {\n  if (!process.env.NPM_TOKEN) {\n    auto.logger.log.warn('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### beforeShipIt\n\nHappens before `shipit` is run. This is a great throw an error if a token or key is not present.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async config => {\n  if (!process.env.NPM_TOKEN) {\n    throw new Error('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### getAuthor\n\nGet git author. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getAuthor.tapPromise('NPM', async () => {\n  const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (author) {\n    return author;\n  }\n});\n```\n\n#### getPreviousVersion\n\nGet the previous version. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getPreviousVersion.tapPromise('NPM', async prefixRelease => {\n  const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (version) {\n    return prefixRelease(\n      JSON.parse(await readFile('package.json', 'utf-8')).version\n    );\n  }\n});\n```\n\n#### getRepository\n\nGet owner and repository. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\n```\n\n#### onCreateRelease\n\nTap into the things the Release class makes. This isn't the same as `auto release`, but the main class that does most of the work.\n\nAvailable hooks:\n\n- onCreateLogParse (detailed [below]())\n- onCreateChangelog (detailed [below]())\n\n```ts\nthis.hooks.onCreateRelease.tap('MyPlugin', release => {\n  release.hooks.onCreateLogParse.tap('Change log parseing', logParse =>\n    // extend logParse\n  );\n\n  release.hooks.onCreateChangelog.tap(\n    'Change changelog',\n    changelog => {\n      // extend changelog\n    }\n  );\n});\n```\n\n#### onCreateChangelog\n\nThis is where you hook into the changelog's hooks. See usage [below](#changelog-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### onCreateLogParse\n\nThis is where you hook into the LogParse's hooks. See usage [below](#logparse-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### version\n\nVersion the package. This is a good opportunity to `git tag` the release also. Here `npm` does it for us.\n\n```ts\nauto.hooks.version.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n});\n```\n\n#### postVersion\n\nRan after the package has been versioned.\n\n#### publish\n\nPublish the package to some package distributor. You must push the tags to github!\n\n```ts\nauto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n  await execPromise('npm', ['publish']);\n  await execPromise('git', [\n    'push',\n    '--follow-tags',\n    '--set-upstream',\n    'origin',\n    '$branch'\n  ]);\n});\n```\n\n#### postPublish\n\nRan after the package has been published.\n\n---\n\n### Changelog Hooks\n\n#### renderChangelogLine\n\nChange how the changelog renders lines. This hook provides the default line renderer so you don't have to change much.\n\nThe following plugin would change all the bullet points in the changelog to star emojis.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Stars',\n    async (commits, renderLine) =>\n      commits.map(commit => `${renderLine(commit).replace('-', ':star:')}\\n`)\n  );\n);\n```\n\n#### renderChangelogTitle\n\nChange how the changelog renders titles. The hook provides the current label for the section and all the configured changelog titles.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogTitle.tap(\n    'My Titles',\n    (label, changelogTitles) => `:heart: ${changelogTitles[label]} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthor\n\nChange how the changelog renders authors. This is both the author on each commit note and the user in the author section (the part between parentheses). This is generally a link to some profile.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthor.tap(\n    'test',\n    (author, commit) => `:heart: ${author.name}/${commit.authorEmail} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthorLine\n\nChange how the changelog renders authors in the authors section. The hook provides the author object and the user created with `renderChangelogAuthor`. Here is where you might display extra info about the author, such as thier full name,.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthorLine.tap(\n    'test',\n    (author, user) => `:shipit: ${author.name} (${user})\\n`\n  );\n);\n```\n\n---\n\n### LogParse Hooks\n\n#### parseCommit\n\nParse information about a commit from a commit. Here is where `auto` gets the PR number from the merge commits.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', logParse =>\n  logParse.hooks.parseCommit.tap(\n    'test',\n    (commit) => {\n      const bump = getBump(commit.subject, logParse.options.versionLabels);\n      commit.labels = [bump]\n      return commit;\n    }\n  );\n);\n```\n\n#### omitCommit\n\nChoose to omit certain commits. If you return true the commit will be omitted. Be sure to return nothing if you don't want the commit omitted.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', changelog =>\n  changelog.hooks.omitCommit.tap(\n    'test',\n    (commit) => {\n      if (someTest(commit.subject)) {\n        return true;\n      }\n    }\n  );\n);\n```\n\n## Example Plugin - NPM (simple)\n\nTo create a plugin simply make a class with an `apply` method and tap into the hooks you need.\n\n```ts\nimport * as fs from 'fs';\nimport { promisify } from 'util';\n\nimport { IAutoHooks, Auto, SEMVER, execPromise } from 'auto';\nimport getConfigFromPackageJson from './package-config';\n\nconst readFile = promisify(fs.readFile);\n\nexport default class NPMPlugin {\n  public apply(auto: Auto) {\n    auto.hooks.getAuthor.tapPromise('NPM', async () => {\n      const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      if (author) {\n        auto.logger.log.info('NPM: Got author information from package.json');\n        return author;\n      }\n    });\n\n    auto.hooks.getPreviousVersion.tapPromise('NPM', async prefixRelease => {\n      const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      auto.logger.log.info(\n        'NPM: Got previous version from package.json - ',\n        version\n      );\n\n      if (version) {\n        return prefixRelease(\n          JSON.parse(await readFile('package.json', 'utf-8')).version\n        );\n      }\n    });\n\n    auto.hooks.getRepository.tapPromise('NPM', async () => {\n      auto.logger.log.info('NPM: getting repo information from package.json');\n      return getConfigFromPackageJson();\n    });\n\n    auto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n      await execPromise('npm', [\n        'version',\n        version,\n        '-m',\n        'Bump version to: %s [skip ci]'\n      ]);\n      await execPromise('npm', ['publish']);\n      await execPromise('git', [\n        'push',\n        '--follow-tags',\n        '--set-upstream',\n        'origin',\n        '$branch'\n      ]);\n    });\n  }\n}\n```\n"}];e.default=o,n.exports=e.default}}]);
//# sourceMappingURL=search-files.js.map